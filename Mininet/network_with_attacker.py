#!/usr/bin/python2.7
"""
networks.py
Creates virtual networks with the use of Mininet's Python API. All networks configured are split into multiple
subnetworks, a SDN-based network and outside users. This simulates users connecting to the protected network via the
Internet. Input is generated by generate_config.py, such as number of hosts, scan types, controller type, ...
"""

import topo_helper
from itertools import cycle, zip_longest
from collections import OrderedDict
import sys
import os.path
import json
import time
import re

# Mininet imports
from mininet.net import Containernet
from mininet.node import RemoteController, Controller
from mininet.cli import CLI
from mininet.clean import Cleanup
from mininet.log import setLogLevel
from mininet.topo import Topo  # Parent to topology class
from mininet.link import TCLink

Topos = {}

TCP_SCANS = ("sS", "sT", "sN", "sF", "sX")
UDP_SCANS = ("sU")

def read_config():
    """
    Read in JSON config file.
    :return: Dictionary containing the content in the config file.
    """
    f = open("./Ryu/hosts_ports.json")
    content = json.loads(f.read())
    f.close()
    return content

#------------------Containernet---------------------------------------------------------------------------------------

def create_network(config, is_containernet, mode):
    net = Containernet(controller=RemoteController, link=TCLink)
    net.addController(name="c0", ip='127.0.0.1', port=6653)
    
    num_hosts = int(config.get("num_hosts"))
    controller_type = config.get("controller_type")

    o1 = net.addHost('o1', ip="10.0.4.10/22", mac="00:00:00:00:01:01")  # Outsider
    if mode == ALL_CONTAINER or mode == ONE_VUL_TWO_ATTACKER:
        r1 = net.addDocker('r1', ip="10.0.0.1/22", mac="00:00:00:00:00:01", dimage="rightscale/openvas")  # Router
        a2 = net.addDocker('a2', ip="10.0.0.2/22", mac="00:00:00:00:00:02", dimage="hal3002/metasploit")
    elif mode == ALL_VUL_ONE_ATTACKER:
        r1 = net.addDocker('r1', ip="10.0.0.1/22", mac="00:00:00:00:00:01", dimage="rightscale/openvas")  # Router
        a2 = net.addHost('a2', ip="10.0.0.2/22", mac="00:00:00:00:00:02")
    elif mode == NO_CONTAINER:    
        r1 = net.addHost('r1', ip="10.0.0.1/22", mac="00:00:00:00:00:01")
        a2 = net.addHost('a2', ip="10.0.0.2/22", mac="00:00:00:00:00:02")

    # Static number of switches
    linkparams = {'delay': '0.5ms'}  # Default link params
    s1 = net.addSwitch('s1', dpid='0000000000000001')
    s2 = net.addSwitch('s2', dpid='0000000000000002')
    s3 = net.addSwitch('s3', dpid='0000000000000003')
    net.addLink(s1, r1, port1=1, **linkparams)
    net.addLink(s1, a2, port1=4, **linkparams)
    net.addLink(s2, s1, port1=1, port2=2, **linkparams)
    net.addLink(s3, s1, port1=1, port2=3, **linkparams)
    net.addLink(r1, o1, bw=10, delay='15ms')  # Delay is doubled as it is applied on interfaces
    c = cycle([s1, s2, s3])

    # rIPs of hosts begin from 2
    for i in range(3, 3 + int(num_hosts)):
        # if i == 6 and is_containernet:
        #     # h6 : metasploitable
        #     host = net.addDocker("h{}".format(i), ip="10.0.0.{}/22".format(i), dimage="tleemcjr/metasploitable2")
        # else:
        #     host = net.addHost("h{}".format(i), ip="10.0.0.{}/22".format(i))
        host = create_host(net, i, mode)
        net.addLink(next(c), host, **linkparams)
    return net

def create_host(net, index, mode):
    if mode == ALL_CONTAINER or mode == ALL_VUL_ONE_ATTACKER:
        return net.addDocker("h{}".format(index), ip="10.0.0.{}/22".format(index), dimage="tleemcjr/metasploitable2")
    elif mode == ONE_VUL_TWO_ATTACKER: # only h6 is a metasploitable container
        if index == 6:
            return net.addDocker("h{}".format(index), ip="10.0.0.{}/22".format(index), dimage="tleemcjr/metasploitable2")
        else:
            return net.addHost("h{}".format(index), ip="10.0.0.{}/22".format(index))
    elif mode == NO_CONTAINER:
        return net.addHost("h{}".format(index), ip="10.0.0.{}/22".format(index))


def start_network(net, config, is_containernet, mode):
    # Fetch all hosts from the network
    r1 = net.get('r1')
    o1 = net.get('o1')

    # Extra configurations to network
    net.start()
    topo_helper.disable_ipv6(net)
    topo_helper.configure_router(r1, ("10.0.0.1/22", "10.0.4.1/22")) # add two subnet interfaces to router1
    topo_helper.add_default_route(net, r1.IP())
    o1.cmd("ip route add default via 10.0.4.1")

    configure_hosts(net, mode, config)
    generate_switch_connections_file(net)
    nmap_scanning(net, config)
    CLI(net)
    net.stop()

def get_command_params(raw_command, config):
    # timeout
    timeout_value = raw_command.get("nmap_time_out")
    if timeout_value == 0:
        timeout = {"cmd":"", "filename":"0"}
    else:
        timeout = {
            "cmd":"timeout {}".format(timeout_value),
            "filename":timeout_value
        }
    # scan type
    scan_type = {
        "cmd":"-" + raw_command.get("nmap_scan_type"),
        "filename":raw_command.get("nmap_scan_type"),
    }
    # ports discovered
    if raw_command.get("nmap_port_discovered"):
        port_list = config.get("0")
        ports = {
            "cmd":"-p {}".format(",".join(map(str, port_list))),
            "filename":"discovered",
        }
    else:
        ports = {
            "cmd":"-p 1-9000",
            "filename":"1-9000",
        }
    return timeout, scan_type, ports, raw_command.get("start_index"), raw_command.get("end_index")

# command_series: the same nmap command with different filenames(different file indexes)
def generate_command_series(raw_command, config):
    timeout, scan_type, ports, start_index, end_index = get_command_params(raw_command, config)
    command_series = []
    for i in range(start_index, end_index):
        filename = "nmap_Time{}_Scan{}_Port{}_{}.xml".format(
            timeout.get("filename"), scan_type.get("filename"), ports.get("filename"), i)
        command = "{} nmap {} {} -oX {} ".format(
            timeout.get("cmd"), scan_type.get("cmd"), ports.get("cmd"), filename)
        command += "--exclude 10.0.0.1,10.0.0.2 -Pn --max-retries 0 --max-rtt-timeout 1000ms 10.0.0.0/22 &"
        command_series.append(command)
    return command_series

def generate_all_commands(config):
    raw_commands = config.get("commands")
    command_series_list = []
    for raw_command in raw_commands:
        command_series_list.append(generate_command_series(raw_command, config))
    # run commands from all the series in a round-robin fashion
    all_commands = [cmd for column in zip_longest(*command_series_list) for cmd in column if cmd is not None]
    return all_commands

def nmap_scanning(net, config):
    mtd_time = config.get("mtd_time")
    all_commands = generate_all_commands(config)
    parallel_commands_num = config.get("parallel_commands_num")
    r1 = net.get('r1')
    while len(all_commands):
        # fetch some commands to execute at the same time
        commands_to_execute = all_commands[0:parallel_commands_num]
        del all_commands[0:parallel_commands_num]

        # execute commands and record their pids
        for index, command in enumerate(commands_to_execute):
            r1.cmd(command)
            print(command)
            r1.cmd("BACK_PID_{}=$!".format(index))
            r1.cmd("sleep 0.8")
        # remaining time
        remaining_seconds = int((mtd_time * len(all_commands))/5)
        left_hours = int(remaining_seconds/3600)
        minutes = int((remaining_seconds - left_hours*3600)/60)
        print("     remaining time:{}h{}m".format(left_hours, minutes))

        # wait until commands complete
        pids = ""
        for index in range(len(commands_to_execute)):
            pids += "$BACK_PID_{} ".format(index)
        r1.cmd("wait {}".format(pids)) 
        # clear arp cache
        topo_helper.remove_all_ARP_cache(net)
    else:
        print("*"*30)
        print((("*"+" "*28+"*\n")*3)[0:-1])
        print("*   experiment finished!     *")
        print((("*"+" "*28+"*\n")*3)[0:-1])
        print("*"*30)


def configure_hosts(net, mode, config):
    if mode == ALL_CONTAINER:
        # start openvas services
        r1 = net.get('r1')
        start_host_openvas_services(r1)
        # start metasploitable services
        # h3 ~ h7
        for i in range(3, 8):
            h = net.get("h{}".format(i))
            h.cmd("/bin/services.sh")
    elif mode == ALL_VUL_ONE_ATTACKER:
        # start openvas services
        r1 = net.get('r1')
        start_host_openvas_services(r1)
        # start metasploitable services
        # h3 ~ h7
        for i in range(3, 8):
            h = net.get("h{}".format(i))
            h.cmd("/bin/services.sh")
    elif mode == ONE_VUL_TWO_ATTACKER:
        # start openvas services
        r1 = net.get('r1')
        start_host_openvas_services(r1)
        # start metasploitable services
        h6 = net.get('h6')
        h6.cmd("/bin/services.sh")
    elif mode == NO_CONTAINER:
        topo_helper.open_host_ports(net, config, "udp")

def start_host_openvas_services(host):
    host.cmd("openvas-mkcert -f \n\n\n\n\n\n\n")
    host.cmd("openvas-mkcert-client -i -n")
    host.cmd('openvasmd '+\
        '--modify-scanner "08b69003-5fc2-4037-a479-93b440211c73" '+\
        '--scanner-ca-pub /usr/local/var/lib/openvas/CA/cacert.pem '+\
        '--scanner-key-pub  /usr/local/var/lib/openvas/CA/clientcert.pem '+\
        '--scanner-key-priv /usr/local/var/lib/openvas/private/CA/clientkey.pem')
    host.cmd('service redis-server restart')
    host.cmd('/openvas/startup.sh & ')

def generate_switch_connections_file(net):
    result = {}
    for switch in net.switches:
        result[switch.dpid] = {}
        for port in switch.intfs:
            if port == 0: # port0 is loopback
                continue
            interface = switch.intfs[port]
            connected_interface = get_connected_interface(interface)
            connected_node = connected_interface.node
            if re.match(r'^h\d+$|^r\d+$|^a\d+$', connected_node.name):
                result[switch.dpid][port] = (connected_node.name, connected_interface.ip)
            elif re.match(r'^s\d+$', connected_node.name):
                result[switch.dpid][port] = (connected_node.name, connected_node.dpid)
    print(result)
    with open("switch_connections.json", "w") as f:
        json.dump(result, f, indent=4, sort_keys=True)

def get_connected_interface(interface):
    if interface.link: # interface itself is in a link
        link_intfs = [ interface.link.intf1, interface.link.intf2 ]
        link_intfs.remove(interface) # remove itself, the left is the other interface
        return link_intfs[0]

# network modes
ALL_CONTAINER = 1 # all hosts are containers
ALL_VUL_ONE_ATTACKER = 2
ONE_VUL_TWO_ATTACKER = 3 # one vulnerable container, two attackers(openvas and metasploit)
NO_CONTAINER = 4 # all hosts are not container


def main():
    config = read_config()
    is_containernet = True
    selected_mode = ALL_CONTAINER # network mode
    net = create_network(config, is_containernet, selected_mode)
    start_network(net, config, is_containernet, selected_mode)


if __name__ == '__main__':
    setLogLevel('info')
    main()